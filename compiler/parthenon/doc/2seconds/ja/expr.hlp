ＥＸＰＲ


機　能　　　式を評価します。

形　式　　　ｅｘｐｒ　式

パラメータ　式：ファンクターで記述された式を指定します。
　　　　　　　　ファシリティを直接指定できます。

実行例　　　2SECONDS> expr ( and %B4%1111 %B4%0000 )
　　　　　　%B4%0000
　　　　　　2SECONDS> expr ( concat ( string abc ) ( string def ) )
　　　　　　' abcdef '
　　　　　　2SECONDS>

注意事項　　・ビット列定数の指定方法は,基数,ビット幅,ビット部分列から構成され,その書式は,
　　　　　　　「％基数(B,D,O,X)ビット幅％ビット部分列」となります。
　　　　　　・ビット部分列として扱えるビット値は,"0","1","u"(unknown),"?"(don't care)であ
　　　　　　　り,基数としては,"B","D","O","X"を使用できます。　　　　　　
　　　　　　・ビット幅の指定が省略された場合,ビット幅は,２,８,１６進表記では数字の字数を
　　　　　　　１,３,４倍したものが仮定され,１０進表記では一律３２ビットと仮定されます。
　　　　　　・stringファンクターを使用して文字列を指定することもできます。　　　　　　
　　　　　　・評価結果はシステム変数EXPRに設定されます。

関連事項　　EXPRNコマンド
          　SETBASEコマンド

                    Expressionsクイックリファレンス
+-------------------------------------------------------------------------------------------+
|   Functer        |                                 Returns                                |
+-------------------------------------------------------------------------------------------+
|( now )           |  current time.                                                         |
+-------------------------------------------------------------------------------------------+
|( null )          |'not-driven'                                                            |
+-------------------------------------------------------------------------------------------+
|( insull )        | B1 if e is 'not -driven'.                                              |
+-------------------------------------------------------------------------------------------+
|( has0 e )        | B1 if e has bit-value '0'.                                             |
+-------------------------------------------------------------------------------------------+
|( has1 e )        | B1 if e has bit-value '1'.                                             |
+-------------------------------------------------------------------------------------------+
|( hasu e )        | B1 if e has bit-value 'u'.                                             |
+-------------------------------------------------------------------------------------------+
|( hasdc e )       | B1 if e has bit-value '?'(don't care).                                 |
+-------------------------------------------------------------------------------------------+
|( parity e )      | exclusive-or of all bit-values in e.                                   |
+-------------------------------------------------------------------------------------------+
|( size e )        | bit-length of e.                                                       |
+-------------------------------------------------------------------------------------------+
|( comp e1 )       | bitwise complement of e.                                               |
+-------------------------------------------------------------------------------------------+
|( and e1 e2 )     | bitwise and of e1 and e2.                                              |
+-------------------------------------------------------------------------------------------+
|( or e1 e2 )      | bitwise or of e1 and e2.                                               |
+-------------------------------------------------------------------------------------------+
|( xor e1 e2 )     | bitwise exclusive-or of e1 and e2.                                     |
+-------------------------------------------------------------------------------------------+
|( exp e1 e2 )     | enlarge the e1 to e2 bits prepending MSB values.                       |
+-------------------------------------------------------------------------------------------+
|( substr e1 e2 )  | substring of the e1  from e2 to e3.                                    |
+-------------------------------------------------------------------------------------------+
|( concat e1 e2 )  | concatenates e2 to e1 on the right.                                    |
+-------------------------------------------------------------------------------------------+
|( merge e1 e2 )   | replace e1's bits by e2's expect '?' bits.                             |
+-------------------------------------------------------------------------------------------+
|( match e1 e2 )   | B1 if merged value of e1 and e2 is same value e1.                      |
+-------------------------------------------------------------------------------------------+
|( eq e1 e2 )      | B1 if e1 == e2.                                                        |
+-------------------------------------------------------------------------------------------+
|( ne e1 e2 )      | B1 if e1 ! = e2.                                                       |
+-------------------------------------------------------------------------------------------+
|( gt e1 e2 )      | B1 if e1 > e2.                                                         |
+-------------------------------------------------------------------------------------------+
|( ge e1 e2 )     | B1 if e1 >= e2.                                                         |
+-------------------------------------------------------------------------------------------+
|( lt e1 e2 )     | B1 if e1 < e2.                                                          |
+-------------------------------------------------------------------------------------------+
|( le e1 e2 )     | B1 if e1 <= e2.                                                         |
+-------------------------------------------------------------------------------------------+
|( add e1 e2 )    | e1 + e2.                                                                |
+-------------------------------------------------------------------------------------------+
|( sub e1 e2 )    | e1 - e2.                                                                |
+-------------------------------------------------------------------------------------------+
|( mul e1 e2 )    | e1 * e2.                                                                |
+-------------------------------------------------------------------------------------------+
|( div e1 e2 )    | e1 / e2.                                                                |
+-------------------------------------------------------------------------------------------+
|( mod e1 e2 )    | e1 % e2.                                                                |
+-------------------------------------------------------------------------------------------+
|( tasks S )      | number of active tasks in the srtage S.                                 |
+-------------------------------------------------------------------------------------------+
|( ntasks S )     | number of active tasks on the next cycle in the stage S.                |
+-------------------------------------------------------------------------------------------+
|( width F )      | bit-length of the facility F ,for state-valued facilities it returns 0. |
+-------------------------------------------------------------------------------------------+
|( length M )     | words of the memory M ,for scolor facilities it returns 1.              |
+-------------------------------------------------------------------------------------------+
|( writing F )    | B1 if the facility F is updated(register-type) or driven(terminal-type).|
+-------------------------------------------------------------------------------------------+
|( staying S )    | B1 if the current state of S is out of any segments.                    |
+-------------------------------------------------------------------------------------------+
|( staying G )    | B1 if the current state of a stage is in the segment G.                 |
+-------------------------------------------------------------------------------------------+
|( nstaying S )   | B1 if the next state of S is out of any segments.                       |
+-------------------------------------------------------------------------------------------+
|( nstaying G )   | B1 if the next state of a stage is in the segment G                     |
+-------------------------------------------------------------------------------------------+
|( starting T )   | B1 if the task T is being invoked.                                      |
+-------------------------------------------------------------------------------------------+
|( starting S )   | B1 if one of the tasks in stage S is being invoked.                     |
+-------------------------------------------------------------------------------------------+
|( ending T )     | B1 if the task T is terminating.                                        |
+-------------------------------------------------------------------------------------------+
|( ending S )     | B1 if one of the tasks in stage S is terminating.                       |
+-------------------------------------------------------------------------------------------+
|( ref F )        | the current value of the scolar facility F.                             |
+-------------------------------------------------------------------------------------------+
|( next F )       | the next value of the scolar facility F.                                |
+-------------------------------------------------------------------------------------------+
|( mref M i )     | the memory content of address i of memory M.                            |
+-------------------------------------------------------------------------------------------+
|( mnext M i )    | the next value for address i of memory M.                               |
+-------------------------------------------------------------------------------------------+
|( mwriting M i ) | B1 if address i of memory M is being updated.                           |
+-------------------------------------------------------------------------------------------+
|( cond e1 e2 e3 )| if e1 become B1 then e2 ,othewise e3.                                   |
+-------------------------------------------------------------------------------------------+
|( index e1 e2 )  | the left-most position of substring matched to regular expression e2.   |
+-------------------------------------------------------------------------------------------+
|( rindex e1 e2 ) | the right-most position of substring matched to regular expression e2.  |
+-------------------------------------------------------------------------------------------+
|( string e )     | string leteral e.                                                       |
+-------------------------------------------------------------------------------------------+

