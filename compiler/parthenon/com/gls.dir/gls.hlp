/*===================================================================*
 *=====                                                         =====*
 *=====       Sfl Extended CONversational Design System         =====*
 *=====              Version  1.0   Date  1991.2.20             =====*
 *=====                                                         =====*
 *=====       Confidential property of N.T.T.                   =====*
 *=====       (c) Copyright N.T.T. 1991  (unpublished)          =====*
 *=====              All rights reserved.                       =====*
 *=====                                                         =====*
 *===================================================================*/

 =====================================================================
 ===                                                               ===
 === help file grammer are as follows ...                          ===
 ===                                                               ===
 ===  "\n^@^XXXX" : command header mark ( XXXX is a command name ) ===
 ===  "\n<more>"  : display pause  mark ( waiting to hit CR key. ) ===
 ===                                                               ===
 ===  note :  main menu use the second line of each command        ===
 ===                                                               ===
 =====================================================================


^@^
[1]main menu head line
--- available commands are as follews ---


^@^alias
[1]function:
  set another name to specified facility
[2]command format:
  alias  [ <facility> [ <name> ] ]
[3]parameter:
  <facility> := facility name
  <name>     := alias name
[4]note:
  if <name> is not specified : display alias name of specified <facility>
  if  both are not specified : display all alias


^@^bind
[1]function:
  reconstitute facility divided to each bit
[2]command format:
  1.  bind  [ <name>  <pin-list> ]
  2.  bind  <bind>
[3]parameter:
  <name>     := reconstruction facility name
  <pin-list> := <pin> [ <pin-list> ]
  <pin>      := pin name (terminal pin | component pin)
  <bind>     := defined name by bind command
[4]note:
  in <pin-list>, the first <pin> is LSB pin as bit-0.
  it can be use "<bind>[N]" instead of the N-th <pin> in <pin-list>.
  if all parameter are not specified : display all bind name
  if <bind> is specified  : display all pin name reconstituted as <bind>


^@^bit_max
[1]function:
  set simulation bit size for each value
[2]command format:
  bit_max  [ <size> ]
[3]parameter:
  <size>  :=  1 to 16
[4]note:
	 if <size> is not specified : display present bit size.
     this simulation bit size can't change after nldread.


^@^bit_sel
[1]function:
  select bit position for "memset","memclr","set <bind>" command
[2]command format:
  bit_sel  [ <bit> ]
[3]parameter:
  <bit>  :=  0 to 15
[4]note:
	 if <bit> is not specified : display present bit position.


^@^bye
[1]function:
  exit from this simulator
[2]command format:
  bye
[3]parameter:
  none
[4]note:
  return to system


^@^claim
[1]function:
  write claiming stream to specified file
[2]command format:
  claim  [ <file> ]
[3]parameter:
  <file> := output file name
[4]note:
  if already <file> exist    : over write mode
  if <file> is not specified : write into stderr


^@^claima
[1]function:
  append claiming stream to specified file
[2]command format:
  claima  [ <file> ]
[3]parameter:
  <file> := output file name
[4]note:
  if already <file> exist    : append write mode
  if <file> is not specified : write into stderr


^@^clk_log
[1]function:
  define simulation logic sequence in a clock
[2]command format:
  clk_log
[3]parameter:
  none
[4]note:
  data set after prompt("->") following
[5]data set sub-commands:
  1. <end>      := end                    # conclude with update data
  2. <set>      := set <pin-name> <value> # pin data set command
  3. <sim>      := "simulation"           # logic simulation execute
  4. <nl>       := '\n'                   # conclude without update data

  <pin-name>    := pin name (terminal pin | component pin)
  <value>       := SFL number | pin name


^@^define
[1]function:
  define script macro word
[2]command format:
  define  <macro> [ <strings> ]
[3]parameter:
  <macro>    := <name> | <name>( <arg-list> )
  <name>     := macro name
  <arg-list> := <symbol> [ <arg-list> ]
  <symbol>   := symbol name
[4]note:
  the <symbol> in <strings> is replaced by real argument of using macro.
  if <strings> is not specified : <macro> become undefined


^@^describe
[1]function:
  describe facility in detail
[2]command format:
  describe  [ { <facility> } ]
[3]parameter:
  <facility> := facility name | bind name
[4]note:
  if no <facility> is specified : display module information


^@^dir
[1]function:
  set or display current working directory
[2]command format:
  dir  [ <pathname> ]
[3]parameter:
  <pathname> := directory path
[4]note:
  if <pathname> is not specified : display current directory path


^@^echo
[1]function:
  echo back input command to display itself
[2]command format:
  echo  { <parameter> }
[3]parameter:
  <parameter> := any token
[4]note:


^@^else
[1]function:
  execute following command, if last if-condition was fault
[2]command format:
  else <command>
[3]parameter:
  <command> := any GLS command
[4]note:


^@^eval
[1]function:
  re-run command interpreter to use specified script
[2]command format:
  eval  <script> [ <argument> ]
[3]parameter:
  <script>   := source strings
  <argument> := number macro body in the <script>
[4]note:
  $0 := "eval"


^@^exec
[1]function:
  execute shell command
[2]command format:
  exec  [ <command> ]
[3]parameter:
  <command> := shell command name
[4]note:
  if <command> is not specified : execute shell


^@^forward
[1]function:
  proceed simulation to stop time
[2]command format:
  [ forward ] [ <stop> ]
[3]parameter:
  <stop> := [+] interger             # simulation stop time
[4]note:
  <stop> with "+" is relative time from now time.
  if <stop> is not specified : it use default stop time setted by stop command.
  if "forward" is not specified : it repeat same forward simulation
                                  by next command "\n" without any script.


^@^gls_dir
[1]function:
  set or display GLS directory
[2]command format:
  gls_dir  [ <pathname> ]
[3]parameter:
  <pathname> := directory path
[4]note:
  if <pathname> is not specified : display GLS directory path



^@^help
[1]function:
  explain each command (this command)
[2]command format:
  help  [ <command> ]
[3]parameter:
  <command> := this simulator command name
[4]note:
  if <command> is not specified : display all available command name


^@^if
[1]function:
  execute following command, if the condition is true
[2]command format:
  if  (  <condition>  )   <command>
[3]parameter:
  <condition> := expression  (must be 1 bit SFL number)
  <command>   := any GLS command
[4]note:
  true condition are as follews ...
    V1 == V2  := if V1 value is equal to V2 value.
    V1 != V2  := if V1 value is not equal to V2 value.
    V1 <> V2  := same as "!=" , except don't care for the unknown bits of V2.
    V1 >  V2  := if V1 value is greater than V2 value.
    V1 <  V2  := if V1 value is less than V2 value.
    V1 >= V2  := if V1 value is greater than V2 value, or equal to.
    V1 <= V2  := if V1 value is less than V2 value, or equal to.
    ^ V1      := complement each bit of V1
    V1 &  V2  := bit and operation for V1 and V2. (V1 and V2 must be same size)
    V1 |  V2  := bit or  operation for V1 and V2. (V1 and V2 must be same size)
    ( V1 )    := same as V1 value
(*1) true  condition is equivalent of SFL number 0B1.
(*2) false condition is equivalent of SFL number 0B0.

^@^lc
[1]function:
  display type of specified facility
[2]command format:
  lc  [ { <facility> } ]
[3]parameter:
  <facility> := facility name | bind name
[4]note:
  if <facility> is not specified : display module information


^@^lcn
[1]function:
  display value of specified facility, and it's net
[2]command format:
  lcn  [ <facility> ]
[3]parameter:
  <facility> := facility name | <item-no>
  <item-no>  := last list item number in lcn command mode
[4]note:
  lcn command display the net list of specified <facility> with item number.
  in lcn command mode, this item number can be use instead of the item itself.
  and in this mode, following additional sub-commands are available.
[5]additional sub-commands:
  1. <item-no>  ...  display net list of specified <item-no>
  2. <nl>  ........  display net list of marked item, or display last list
  3. <to>  ........  seek path in the net from now item to specified item
  4. <way>  .......  display the path found by <to> command
  5. <end>  .......  exit from lcn command mode

<more>
[6]sub-commands function:
  [6.1]<item-no>
    [6.1.1]function
      display net list or component pin list of specified item by <item-no>.
      in this list, the number of specified item is enclosed with "()".
      and, if only one item is possible as next path, it is marked with ">" or
      "<".  the item marked with ">" is forward, and with "<" is backward.
    [6.1.2]command format:
      <item-no>                             # 1, 2, 3, ...
    [6.1.3]parameter:
      none
    [6.1.4]note:
      if it display net list now : display component pin list next.

<more>
  [6.2]<nl>
    [6.2.1]function
      if the item marked with ">" or "<" is in last list, display it's net.
      else display last list again.
    [6.2.2]command format:
      "\n"                                  # "\n"
    [6.2.3]parameter:
      none
    [6.2.4]note:
      the list is same as [6.1]

<more>
  [6.3]<to>
    [6.3.1]function
      seek path in the net from now item enclosed with "()" to specified item.
      and, display possible path count.
    [6.3.2]command format:
      to  <facility>  [ <path-no> ]
    [6.3.3]parameter:
      <facility> := facility name
      <path-no>  := number
    [6.3.4]note:
      <facility> specify target facility.
      <path-no>  specify order of possible path count.
      if <path-no> is not specified : select first path.

<more>
  [6.4]<way>
    [6.4.1]function
      display the found path by <to> command
    [6.4.2]command format:
      way
    [6.4.3]parameter:
      none
    [6.4.4]note:

<more>
  [6.5]<end>
    [6.5.1]function
      exit from lcn command mode
    [6.5.2]command format:
      end | q
    [6.5.3]parameter:
      none
    [6.5.4]note:
      return to normal simulation mode


^@^ldir
[1]function:
  display specified directory
[2]command format:
  ldir  { <pathname> }
[3]parameter:
  <pathname> := directory path
[4]note:


^@^leave
[1]function:
  conclude current script
[2]command format:
  leave  [ <status> ]
[3]parameter:
  <status> := integer number
[4]note:
  <status> has no efect.


^@^list
[1]function:
  display facility structure in source format
[2]command format:
  list  [ <file> ]
[3]parameter:
  <file>  :=  list output file name
[4]note:
  if <file> is not specified : put to speaking file


^@^listen
[1]function:
  re-run command interpreter to use specified file
[2]command format:
  [ listen ]  <file>  { <argument> }
[3]parameter:
  <file>     := script file name
  <argument> := number macro body for this script
[4]note:


^@^nldread
[1]function:
  read NLD source file
[2]command format:
  nldread  <nldfile>
[3]parameter:
  <nldfile> := NLD source file name
[4]note:
  this simulator accept only one NLD file. it reject 2'nd "nldread" command,
  but if <nldfile> is same as 1'st command, simulation re-start.


^@^memclr
[1]function:
  memory block clear (for select set by "bit_set" command)
[2]command format:
  memclr  <memory>  <start>  <end>  <value>
[3]parameter:
  <memory> := memory name
  <start>  := sfl number that decide start address
  <end>    := sfl number that decide end address
  <value>  := sfl number that decide clear data
[4]note:


^@^memset
[1]function:
  set memory data (for select set by "bit_set" command)
[2]command format:
  memset  <memory>  <address>  { <value> }
[3]parameter:
  <memory>  := memory name
  <address> := sfl number that decide start address
  <value>   := sfl number that decide set data
[4]note:


^@^pause
[1]function:
  waiting for CR key input
[2]command format:
  pause
[3]parameter:
  none
[4]note:


^@^pcd_dir
[1]function:
  set or display PCD library directory
[2]command format:
  pcd_dir  [ <pathname> ]
[3]parameter:
  <pathname> := directory path
[4]note:
  if <pathname> is not specified : display PCD library directory path


^@^print
[1]function:
  display facility value with format
[2]command format:
  print  <format>  { <facility> }
[3]parameter:
  <format>   := format strings
  <facility> := facility name | bind name
[4]note:
  if <facility> is memory facilty,
	<memory name> [ ( <cell no> ) ] @ <address>
	   <cell no> := 0, ...
	   <address> := SFL number | <facility>


^@^quit
[1]function:
  conclude current script, and return to console input
[2]command format:
  quit
[3]parameter:
  none
[4]note:


^@^rename
[1]function:
  change facility name
[2]command format:
  rename  <oldname>  <newname>
[3]parameter:
  <oldname> := present facility name
  <newname> := rename name
[4]note:


^@^report
[1]function:
  display all report cell , and report control
[2]command format:
  report  [ on | off | do ]
[3]parameter:
  on  := report enable
  off := report disable
  do  := execute all report cell action
[4]note:
  if no parameter specified : display all report cell contents


^@^rpt_add
[1]function:
  add report cell
[2]command format:
  rpt_add  <key>  <format>  { <facility> }
[3]parameter:
  <key>      := report cell name
  <format>   := format strings
  <facility> := facility name
[4]note:


^@^rpt_mv
[1]function:
  move report cell
[2]command format:
  rpt_mv  <key>  [ <after> ]
[3]parameter:
  <key>   := report cell name
  <after> := report cell name
[4]note:


^@^rpt_off
[1]function:
  disable report for specified cell
[2]command format:
  rpt_off  { <key> }
[3]parameter:
  <key> := report cell name
[4]note:


^@^rpt_on
[1]function:
  enable report for specified cell
[2]command format:
  rpt_on  { <key> }
[3]parameter:
  <key> := report cell name
[4]note:


^@^rpt_rmv
[1]function:
  delete report cell
[2]command format:
  rpt_rmv  { <key> }
[3]parameter:
  <key> := report cell name
[4]note:


^@^sch_add
[1]function:
  add schedule cell
[2]command format:
  sch_add  <time>  <key>  <script>  { <argument> }
[3]parameter:
  <time>     := schedule time
  <key>      := schedule cell name
  <script>   := source strings
  <argument> := number macro body in the <script>
[4]note:


^@^sch_mv
[1]function:
  move schedule cell
[2]command format:
  sch_mv  <time>  <key>  <new_time>  [ <after> ]
[3]parameter:
  <time>     := schedule time
  <key>      := schedule cell name
  <new_time> := new schedule time
  <after>    := schedule cell name
[4]note:


^@^sch_rmv
[1]function:
  delete scedule cell
[2]command format:
  sch_rmv  <time>  { <key> }
[3]parameter:
  <time> := schedule time
  <key>  := schedule cell name
[4]note:


^@^schedule
[1]function:
  display all schedule cell contents
[2]command format:
  schedule
[3]parameter:
  none
[4]note:


^@^set
[1]function:
  set facility value
[2]command format:
  set  <facility>  <value>
[3]parameter:
  <facility> := facility name | bind name
  <value>    := sfl number that decide set data
[4]note:
  if <facility> is bind name, set <value> for present bit position of each 
   binded facility. (present bit position was selected by bit_sel command.)


^@^setenv
[1]function:
  define environment macro word
[2]command format:
  setenv  <macro> [ <strings> ]
[3]parameter:
  <macro>    := <name> | <name>( <arg-list> )
  <name>     := macro name
  <arg-list> := <symbol> [ <arg-list> ]
  <symbol>   := symbol name
[4]note:
  the <symbol> in <strings> is replaced by real argument of using macro.
  if <strings> is not specified : <macro> become undefined.


^@^settab
[1]function:
  set tab count
[2]command format:
  settab  [ <number> ]
[3]parameter:
  <number> := interger number  ( >0 & <32 )
[4]note:
  if <number> is not specified : display present tab count


^@^sleep
[1]function:
  set seconds sleep time
[2]command format:
  sleep  <time>
[3]parameter:
  <time> := sleep time ( 1 second sleep / unit )
[4]note:


^@^speak
[1]function:
  write speaking stream to specified file
[2]command format:
  speak  [ <file> ]
[3]parameter:
  <file> := output file name
[4]note:
  if already <file> exist    : over write mode
  if <file> is not specified : write into stdout


^@^speaka
[1]function:
  append speaking stream to specified file
[2]command format:
  speaka  [ <file> ]
[3]parameter:
  <file> := output file name
[4]note:
  if already <file> exist    : append write mode
  if <file> is not specified : write into stdout


^@^stop
[1]function:
  set default stop time
[2]command format:
  stop  [ <stop-time> ]
[3]parameter:
  <stop-time> := [+] interger                # simulation stop time
[4]note:
  <stop-time> with "+" is relative time from now time.
  if <stop-time> is not specified : display present default stop time.
  the default stop time is +1000 at simulater start.


^@^then
[1]function:
  execute following command, if last if-condition was true
[2]command format:
  then <command>
[3]parameter:
  <command> := any GLS command
[4]note:


^@^time
[1]function:
  display now simulation time
[2]command format:
  time  [ <time> ]
[3]parameter:
  <time>  :=  0                              # "0" only
[4]note:
  if <time> is specified : simulation re-start


^@^unalias
[1]function:
  delete alias name
[2]command format:
  unalias  { <alias> }
[3]parameter:
  <alias> := alias name
[4]note:


^@^verbose
[1]function:
  command display switch
[2]command format:
  verbose  [ on | off ]
[3]parameter:
  on  := verbose start
  off := verbose stop
[4]note:
  display verbose token to claiming stream


